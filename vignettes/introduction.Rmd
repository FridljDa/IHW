---
title: "Introduction to DDHW"
author: "N. Ignatiadis"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{"Introduction to DDHW"}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

# Introduction

A classical multiple testing procedure takes a set of p-values and then calculates adjusted p-values. Given a significance level $\alpha$, one can then declare the significant (rejected) hypotheses. In R this is most commonly done with the p.adjust function. 

Similarly, DDHW is also a multiple testing procedure, but beyond the p-values, it also requires a covariate (filter statistic) which is independent of the p-values under the null hypothesis. Therefore the basic input of DDHW is the following

* A vector of p-values
* A vector of covariates (filter-statistics), independent of the p-values under the null hypothesis
* A signifance level $\alpha \in (0,1)$ at which the False Discovery Rate should be controlled.

DDHW then calculates weights for each p-value and also a vector of rejected hypothesis at the specified significance level. Roughly speaking, the weights allow different prioritization of the individual hypotheses, based on their covariate.

If this covariate also happens to be informative about the power of the individual tests, then we can actually gain a lot of power compared to an unweighted method (an unweighted method is a weighted method where all tests are assigned weight 1).

In this vignette, we will show how to use the package in differential gene expression RNA-Seq analysis and then also mention some other examples where our method is applicable.

# DDHW and DESeq2

Here we analyze the airway RNA-Seq dataset using DESeq2.

```{r, message=FALSE, warning=FALSE}
library("airway")
library("DESeq2")
data("airway")
dds <- DESeqDataSet(se = airway, design = ~ cell + dex)
dds <- DESeq(dds)
res <- results(dds)
```

The output is a standard DESeqResults object, which includes the following columns for each gene:

```{r}
colnames(res)
```

In particular, we have p-values and the baseMean of (normalized) counts for each gene. As argued in the DESeq2 paper, these two statistics are approximately independent under the null hypothesis. Thus we have all the ingredient necessary for a DDHW analysis (p-values and covariates), which we will apply at a significance level 0.1.

First load DDHW
```{r, message=FALSE, warning=FALSE}
library("DDHW")
```

Then apply it:

```{r}
ddhw_res <- ddhw(res$pvalue, res$baseMean, .1)
```

This returns an object of the class ddhwResult. We can get e.g. the total number of rejections at our pre-specified significance level alpha:

```{r}
rejections(ddhw_res)
```

And we can also extract the adjusted p-values:
```{r}
head(adj_pvalues(ddhw_res))
sum(adj_pvalues(ddhw_res) <= 0.1, na.rm=TRUE) == rejections(ddhw_res)
```

We can compare this to the result of applying Benjamini Hochberg on the p-values:

```{r}
padj_bh <- p.adjust(res$pvalue, method="BH")
sum(padj_bh <= 0.1, na.rm=TRUE)
```

We thus get a lot more rejections! How did we get this power? Essentially it was possible by assigning appropriate weights to each hypothesis! We can retrieve the weights as follows:

```{r}
head(weights(ddhw_res))
```

Basically, a hypothesis with weight > 1 gets prioritized in the testing procedure and the higher the weight the higher the prioritization. On the other hand, a hypothesis with weight equal to 0 cannot be rejected and essentially is filtered out of the procedure.

Internally, what happened was the following: We split the hypotheses into $n$ different strata based on increasing value of baseMean and we also randomly split them into $k$ folds (here $k=5$). Then, for each combination of folds + stratum, we learned the weights. The discretization into strata facilitates the estimation of the distribution function conditionally on the covariate and the internal optimization which estimates the weights. The division into random folds helps us to avoid "overfitting" the data, something which would result in a loss of control of the False Discovery Rate.

We can also see this internal representation of the weights as a ($n$ X $k$) matrix:

```{r}
weights(ddhw_res, levels_only=TRUE)
```

Finally, DDHW contains a convenience function for visualization of the estimated weights:

```{r}
plot_ddhw(ddhw_res)
```

Here we see that the general trend is driven by the covariate (stratum) and not as much by the fold. Also as expected, genes with very low baseMean count get assigned a weight of 0, while genes with high baseMean count get prioritized.

# Regarding the covariate

In which cases is DDHW applicable? Whenever we have a covariate which is both informative of power and independent of the p-values under the null hypothesis.

Below we summarize some examples, where such a covariate is available:

Examples:
 
 *  For row-wise $t$-tests  we can use the overall (row-wise) variance 
 *  For Rank tests  we can use any function that does not depend on order of arguments  
 *  In DESeq2, we can use baseMean, as illustrated above.
 *  In  eQTL analysis we can use the SNP-gene distance, the DNAse sensitivity, the HiC score, etc. 


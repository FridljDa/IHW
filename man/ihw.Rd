% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ihw_convex.R
\name{ihw}
\alias{ihw}
\title{ihw: Main function for Independent Hypothesis Weighting}
\usage{
ihw(pvalues, covariates, alpha, covariate_type = "ordinal", nbins = "auto",
  m_groups = NULL, quiet = TRUE, nfolds = 5L, nfolds_internal = 5L,
  nsplits_internal = 1L, lambdas = "auto", seed = 1L,
  distrib_estimator = "grenander", lp_solver = "lpsymphony",
  adjustment_type = "BH", return_internal = FALSE, ...)
}
\arguments{
\item{pvalues}{Numeric vector of unadjusted p-values.}

\item{covariates}{Vector which contains the one-dimensional covariates (independent under the H0 of the p-value)
for each test. Can be numeric or a factor. (If numeric it will be converted into factor by binning.)}

\item{alpha}{Numeric, sets the nominal level for FDR control.}

\item{covariate_type}{"ordinal" or "nominal" (i.e. whether covariates can be sorted in increasing order or not)}

\item{nbins}{Integer, number of groups into which p-values will be split based on covariate. Use "auto" for
automatic selection of the number of bins. Only applicable when covariates is not a factor.}

\item{m_groups}{Integer vector of length equal to the number of levels of the covariates (only to be specified
when the latter is a factor). Each entry corresponds to the number of hypotheses to be tested in
each group (stratum). To be used when the complete vector of p-values is not available,
but only p-values below a given threshold, for example because of memory reasons.}

\item{quiet}{Boolean, if False a lot of messages are printed during the fitting stages.}

\item{nfolds}{Number of folds into which the p-values will be split for the pre-validation procedure}

\item{nfolds_internal}{Within each fold, a second  (nested) layer of cross-validation can be conducted to choose a good
regularization parameter. This parameter controls the number of nested folds.}

\item{nsplits_internal}{Integer, how many times to repeat the nfolds_internal splitting. Can lead to better regularization
parameter selection but makes ihw a lot slower.}

\item{lambdas}{Numeric vector which defines the grid of possible regularization parameters.
Use "auto" for automatic selection.}

\item{seed}{Integer or NULL. Split of hypotheses into folds is done randomly. To have output of the function be reproducible, 
we set a seed. Use NULL if you don't want a seed.}

\item{distrib_estimator}{Character ("grenander" or "ECDF"). Only use this if you know what you are doing. ECDF with nfolds > 1
or lp_solver == "lpsymphony" will in general be excessively slow, except for very small problems.}

\item{lp_solver}{Character ("lpsymphony" or "gurobi"). Internally, IHW solves a sequence of linear programs, which
can be solved with either of these solvers.}

\item{adjustment_type}{Character ("BH" or "bonferroni") depending on whether you want to control FDR or FWER.}

\item{return_internal}{Returns a lower level representation of the output (only useful for debugging purposes).}

\item{...}{Arguments passed to internal functions.}
}
\value{
A ihwResult object.
}
\description{
Given a vector of p-values, a vector of covariates which are independent of the p-values under the null hypothesis and
a nominal significance level alpha, IHW learns multiple testing weights and then applies the weighted Benjamini Hochberg 
procedure.
}
\examples{

save.seed <- .Random.seed; set.seed(1)
X   <- runif(20000, min=0.5, max=4.5) #covariate
H   <- rbinom(20000,1,0.1)            #hypothesis true or false
Z   <- rnorm(20000, H*X)              #Z-score
.Random.seed <- save.seed
pvalue <- 1-pnorm(Z)                  #pvalue
ihw_res <- ihw(pvalue, X, .1)


}
\seealso{
ihwResult, plot_ihw
}


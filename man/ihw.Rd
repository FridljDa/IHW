% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/ihw_convex.R
\name{ihw}
\alias{ihw}
\title{ihw: Independent Hypothesis Weighting}
\usage{
ihw(pvalues, filter_statistics, alpha, filter_statistic_type = "ordinal",
  nbins = "auto", quiet = TRUE, nfolds = 5L, nfolds_internal = 5L,
  nsplits_internal = 1L, lambdas = "auto", seed = 1L,
  lp_solver = "lpsymphony", return_internal = FALSE, ...)
}
\arguments{
\item{pvalues}{Numeric vector of unadjusted p-values.}

\item{filter_statistics}{Vector which contains the one-dimensional filter-statistics (covariates, independent under the H0 of the p-value)
for each test. Can be numeric or a factor. (If numeric it will be converted into factor by binning.)}

\item{alpha}{Numeric, sets the nominal level for FDR control.}

\item{filter_statistic_type}{"ordinal" or "nominal" (i.e. whether filter statistics can be sorted in increasing order or not)}

\item{nbins}{Integer, number of groups into which p-values will be split based on filter_statistic. Use "auto" for
automatic selection of the number of bins. Only applicable when filter_statistics is not a factor.}

\item{quiet}{Boolean, if False a lot of messages are printed during the fitting stages.}

\item{nfolds}{Number of folds into which the p-values will be split for the pre-validation procedure}

\item{nfolds_internal}{Within each fold, a second  (nested) layer of cross-validation can be conducted to choose a good
regularization parameter. This parameter controls the number of nested folds.}

\item{nsplits_internal}{Integer, how many times to repeat the nfolds_internal splitting. Can lead to better regularization
parameter selection but makes ihw a lot slower.}

\item{lambdas}{Numeric vector which defines the grid of possible regularization parameters.
Use "auto" for automatic selection.}

\item{seed}{Integer or NULL. Split of hypotheses into folds is done randomly. To have output of the function be reproducible,
we set a seed. Use NULL if you don't want a seed.}

\item{lp_solver}{Character ("lpsymphony" or "gurobi"). Internally, ihw solves a sequence of linear programs, which
can be solved with either of these solvers.}

\item{return_internal}{Returns a lower level representation of the output (only useful for debugging purposes).}

\item{...}{Arguments passed to internal functions.}
}
\value{
A ihwResult object.
}
\description{
Given a vector of p-values, a vector of filter-statistics which are independent of the p-values under the null hypothesis and
a nominal significance level alpha, ihw learns multiple testing weights and then applies the weighted Benjamini Hochberg
procedure. When the filter-statistic is informative of the power of the individual tests, this procedure can increase
power.
}
\examples{
set.seed(1)
X   <- runif(20000, min=0.5, max=4.5) #covariate
H   <- rbinom(20000,1,0.1)            #hypothesis true or false
Z   <- rnorm(20000, H*X)              #Z-score
pvalue <- 1-pnorm(Z)                  #pvalue
ihw_res <- ihw(pvalue, X, .1)
}
\seealso{
ihwResult, plot_ihw
}

